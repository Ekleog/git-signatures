#!/usr/bin/env bash

set -o pipefail

VERSION="v0.1.0"
PROGRAM="${0##*/}"
COMMAND="$1"

main(){
	path_check git base64 xargs gpg || exit 1

	case $COMMAND in
		""|"-h"|"--help"|"help"|"usage") usage;;
		"-v"|"--version") cmd_version;;
	esac

	! type "cmd_$COMMAND" > /dev/null && usage

	shift;
	"cmd_$COMMAND" "$@"
}

usage() {
	topic="${1:-}"
	case $topic in

		"" ) cat <<-EOF
		git signatures <command> [<args>]

		Git Signatures is a system for adding and verifying one or more PGP
		signatures to a given git reference.

		Git Signatures works by appending one of more signatures of a given
		ref hash to the git notes interface for that ref at 'refs/signatures'.

		In addition to built in commit signing that allows -authors- to sign,
		Git Signatures allows parties other than the author to issue "approval"
		signatures to a ref, allowing for decentralized cryptographic proof of
		code review. This is also useful for automation use cases where CI
		systems to be able to add a signatures to a repo if a repo if all tests
		pass successfully.

		In practice Git Signatures allows for tamper evident design and brings
		strong code attestations to a deployment process.

		Commands
		--------

		* git signatures pull
			Pull all signatures for all refs from origin.

		* git signatures show
			Show signatures for a given ref.

		* git signatures push
			Push all signatures for all refs to origin.

		* git signatures add
			Add a signature to a given ref.

		* git signatures verify
			Verify signatures for a given ref.

		* git signatures version
			Report the version number.
		EOF
		;;

		"add" ) cat <<-EOF
		git signatures add [options] [<ref>]

		Add PGP signature to a ref.

		Options:

		* --key -k:
		  Specify ID of a local PGP key that should be used for signing

		* --push -p:
		  Automatically push to remote after adding signature locally
		EOF
		;;

		"show" ) cat <<-EOF
		git signatures show [options] [<ref>]

		Show signatures for a given ref

		Options:

		* --raw -r:
		  Show raw output from gnupg
		EOF
		;;

		"pull" ) cat <<-EOF
		git signatures pull [<ref>]

		Pull remote signatures for a given ref from origin
		EOF
		;;

		"push" ) cat <<-EOF
		git signatures push [<ref>]

		Push local signatures for a given ref to origin
		EOF
		;;

		"verify" ) cat <<-EOF
		git signatures verify [options] [<ref>]

		Verify git signatures and only return 0 if conditions met.

		Useful for CI or scripting.

		Options:

		* --min-count=<num> -m <num>:
		  Only return 0 if the specified number of valid signatures exist on
		  the specified ref

		* --trust-db=<name> -t <name>:
		  Specify a specific GnuPG trustdb to validate signatures against.

		  Useful if you want to verify signatures from isolated sets of
		  possible keys.
		EOF
		;;

		"version" ) cat <<-EOF
		git signatures version

		Get current version. Do you really need help with this?
		EOF
		;;

	esac
}

error() {
	code="${1:-}"
	case $code in

		"" ) cat <<-EOF
			Unknown error. Good luck!
		EOF
		;;

		"invalid_private_key" ) read -r -d '' template  <<-EOF
			Unable to create signature.

			This is not a valid private key according to GnuPG: "%s"

			Please set a public public key in your git configuration that has a
			valid local private key you control.

			> gpg --list-secret-keys
			> git config user.signingKey "YOURKEYID"
		EOF
		;;
	esac

	# shellcheck disable=SC2059
	printf "${template}\\n" "${@:2}"
}

path_check() {
	for item in "$@"; do
		if ! command -v "$item" >/dev/null; then
			printf "%s not found in \$PATH \\n" "$item";
			return 1;
		fi
	done
	return 0
}

epoch_to_human() {
	local epoch="$1"
	# BSD and Linux have never agreed on how date is supposed to work...
	printf "%s" "$(date -d @"$epoch" || date -r "$epoch" )"
}

cmd_version() {
	echo "$PROGRAM $VERSION"
}

cmd_add() {
	local opts key_id push=0
	opts="$(getopt -o hk: -l help,key: -n "$PROGRAM" -- "$@")";
	eval set -- "$opts"
	while true; do case $1 in
		-h|--help) usage add; exit 0;;
		-k|--key) key_id="$2"; shift 2 ;;
		-p|--push) push=1; shift ;;
		--) shift; break ;;
	esac done
	[ "$#" -gt 2 ] && usage add && exit 1
	ref=${1:-HEAD}
	key=${key_id:-$(git config user.signingKey)}
	gpg --list-secret-keys "$key" &> /dev/null || {
		error "invalid_private_key" "$key"; exit 1;
	}
	signature=$( \
		git rev-parse "$ref" \
		| gpg --sign --local-user "$key" \
		| base64 -w0 \
	)
	printf "%s" "$signature" | git notes --ref refs/signatures append --file=-
	[[ "$push" -eq "1" ]] && $PROGRAM push
}

cmd_show() {
	local opts raw=0
	opts="$(getopt -o hr -l help,raw -n "$PROGRAM" -- "$@")";
	eval set -- "$opts"
	while true; do case $1 in
		-h|--help) usage show; exit 0;;
		-r|--raw) raw=1; shift ;;
		--) shift; break ;;
	esac done
	[ "$#" -gt 1 ] && usage show && exit 1
	ref=${1:-HEAD}
	if [ "$raw" -ne 1 ]; then
		printf " %-8s | %-16s | %-28s | %-50s \\n" \
			"Status" "Public Key ID" "Date" "Signer"
		printf "=%.0s" {1..105}
		printf "\\n"
	fi
	while IFS='' read -r line; do
		signature_raw=$( \
			printf '%s' "$line" \
			| base64 -d \
			| gpg -d --status-fd=1 2> /dev/null\
		)
		[ "$raw" -eq "1" ] && echo "$signature_raw" && continue
		local sig_status="unknown"
		while read -r values; do
			local key array sig_key sig_date sig_status sig_author
			IFS=" " read -r -a array <<< "$values"
			key=${array[1]}
			case $key in
				"BADSIG"|"ERRSIG"|"EXPSIG"|"EXPKEYSIG"|"REVKEYSIG")
					sig_key="${array[2]}"
					sig_date="$(epoch_to_human "${array[6]}")"
					sig_status="$key"
				;;
				"GOODSIG")
					sig_author="${values:34}"
					sig_key="${array[2]}"
				;;
				"VALIDSIG")
					sig_status="$key"
					sig_date="$(epoch_to_human "${array[4]}")"
				;;
				"SIG_ID")
					sig_date="$(epoch_to_human "${array[4]}")"
				;;
				"NEWSIG")
					sig_author="${sig_author:-Unknown User <${array[2]}>}"
				;;

			esac
		done <<< "$signature_raw"
		printf " %-8s | %10s | %10s | %-30s\\n" \
			"$sig_status" "$sig_key" "$sig_date" "$sig_author"
		unset sig_key sig_date sig_author
	done < <(git notes --ref refs/signatures show "$ref")
}

cmd_pull() {
	# TODO
	[ "$#" -eq 0 ] || { usage pull; exit 1; }
	git fetch origin refs/signatures
	git notes merge -s cat_sort_uniq origin/refs/signatures
}

cmd_push() {
	# TODO
	[ "$#" -eq 0 ] || { usage push; exit 1; }
	git push origin refs/signatures
}

cmd_verify() {
	[ "$#" -eq 0 ] || { usage verify; exit 1; }
	# TODO
}

main "$@"
