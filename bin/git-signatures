#!/usr/bin/env bash

set -o pipefail

VERSION="v0.1.0"
PROGRAM="${0##*/}"
COMMAND="$1"

main(){
	path_check git base64 xargs gpg || exit 1

	case $COMMAND in
		""|"-h"|"--help"|"help") usage;;
		"-v"|"--version") cmd_version;;
	esac

	! type "cmd_$COMMAND" > /dev/null && usage

	shift;
	"cmd_$COMMAND" "$@"
}

usage() {
	topic="${1:-}"
	case $topic in

		"" ) cat <<-EOF
		git signatures <command> [<args>]

		Git Signatures is a system for adding and verifying one or more PGP
		signatures to a given git reference.

		Git Signatures works by appending one of more signatures of a given
		ref hash to the git notes interface for that ref at 'refs/signatures'.

		In addition to built in commit signing that allows -authors- to sign,
		Git Signatures allows parties other than the author to issue "approval"
		signatures to a ref, allowing for decentralized cryptographic proof of
		code review. This is also useful for automation use cases where CI
		systems to be able to add a signatures to a repo if a repo if all tests
		pass successfully.

		In practice Git Signatures allows for tamper evident design and brings
		strong code attestations to a deployment process.

		Commands
		--------

		* git signatures pull
			Pull all signatures for all refs from origin.

		* git signatures show
			Show signatures for a given ref.

		* git signatures push
			Push all signatures for all refs to origin.

		* git signatures add
			Add a signature to a given ref.

		* git signatures verify
			Verify signatures for a given ref.

		* git signatures version
			Report the version number.
		EOF
		;;

		"pull" ) cat <<-EOF
		TODO: add details on pull here
		EOF
		;;

		"show" ) cat <<-EOF
		TODO: add details on show here
		EOF
		;;

		"push" ) cat <<-EOF
		TODO: add details on push here
		EOF
		;;

		"add" ) cat <<-EOF
		TODO: add details on add here
		EOF
		;;

		"verify" ) cat <<-EOF
		TODO: add details on verify here
		EOF
		;;

		"version" ) cat <<-EOF
		TODO: add details on version here
		EOF
		;;

	esac
}

error() {
	code="${1:-}"
	case $code in

		"" ) cat <<-EOF
			Unknown error. Good luck!
		EOF
		;;

		"invalid_private_key" ) read -r -d '' template  <<-EOF
			Unable to create signature.

			This is not a valid private key according to GnuPG: "%s"

			Please set a public public key in your git configuration that has a
			valid local private key you control.

			> gpg --list-secret-keys
			> git config user.signingKey "YOURKEYID"
		EOF
		;;
	esac

	# shellcheck disable=SC2059
	printf "${template}\\n" "${@:2}"
}

path_check() {
	for item in "$@"; do
		if ! command -v "$item" >/dev/null; then
			printf "%s not found in \$PATH \\n" "$item";
			return 1;
		fi
	done
	return 0
}

epoch_to_human() {
	local epoch="$1"
	# BSD and Linux have never agreed on how date is supposed to work...
	printf "%s" "$(date -d @"$epoch" || date -r "$epoch" )"
}

cmd_version() {
	echo "$PROGRAM $VERSION"
}

cmd_add() {
	local opts key_id
	opts="$(getopt -o k: -l key: -n "$PROGRAM" -- "$@")";
	eval set -- "$opts"
	while true; do case $1 in
		-k|--key) key_id="$2"; shift 2 ;;
		--) shift; break ;;
	esac done
	[ "$#" -gt 2 ] && usage add && exit 1
	ref=${1:-HEAD}
	key=${key_id:-$(git config user.signingKey)}
	gpg --list-secret-keys "$key" &> /dev/null || {
		error "invalid_private_key" "$key"; exit 1;
	}
	signature=$( \
		git rev-parse "$ref" \
		| gpg --sign --local-user "$key" \
		| base64 -w0 \
	)
	printf "%s" "$signature" | git notes --ref refs/signatures append --file=-
}

cmd_pull() {
	# TODO
	[ "$#" -eq 0 ] || { usage pull; exit 1; }
	git fetch origin refs/signatures
	git notes merge -s cat_sort_uniq origin/refs/signatures
}

cmd_push() {
	# TODO
	[ "$#" -eq 0 ] || { usage push; exit 1; }
	git push origin refs/signatures
}

cmd_verify() {
	[ "$#" -eq 0 ] || { usage push; exit 1; }
	# TODO
}

cmd_show() {
	printf " %-8s | %-16s | %-28s | %-50s \\n" \
		"Status" "Public Key ID" "Date" "Signer"
	printf "=%.0s" {1..105}
	printf "\\n"
	while IFS='' read -r line; do
		signature_raw=$( \
			printf '%s' "$line" \
			| base64 -d \
			| gpg -d --status-fd=1 2> /dev/null\
		)
		local sig_status="unknown"
		while read -r values; do
			local array=($values)
			local key=${array[1]}
			case $key in
				"BADSIG"|"ERRSIG"|"EXPSIG"|"EXPKEYSIG"|"REVKEYSIG")
					sig_key="${array[2]}"
					sig_date="$(epoch_to_human "${array[6]}")"
					sig_status="$key"
				;;
				"GOODSIG")
					sig_author="${values:34}"
					sig_key="${array[2]}"
				;;
				"VALIDSIG")
					sig_status="$key"
					sig_date="$(epoch_to_human "${array[4]}")"
				;;
				"SIG_ID")
					sig_date="$(epoch_to_human "${array[4]}")"
				;;
				"NEWSIG")
					sig_author="${sig_author:-Unknown User <${array[2]}>}"
				;;

			esac
		done <<< "$signature_raw"
		printf " %-8s | %10s | %10s | %-30s\\n" \
			"$sig_status" "$sig_key" "$sig_date" "$sig_author"
		unset sig_key sig_date sig_author
	done < <(git notes --ref refs/signatures show)
}

main "$@"
