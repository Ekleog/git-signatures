#!/usr/bin/env bash

set -o pipefail

VERSION="v0.1.0"
PROGRAM="${0##*/}"
COMMAND="$1"

main(){
	path_check git base64 xargs gpg || exit 1

	case $COMMAND in
		""|"-h"|"--help"|"help") usage;;
		"-v"|"--version") cmd_version;;
	esac

	! type "cmd_$COMMAND" > /dev/null && usage

	shift;
	"cmd_$COMMAND" "$@"
}

usage() {
	topic="${1:-}"
	case $topic in

		"" ) cat <<-EOF
		git signatures <command> [<args>]

		Git Signatures is a system for adding and verifying one or more PGP
		signatures to a given git reference.

		Git Signatures works by appending one of more signatures of a given
		ref hash to the git notes interface for that ref at 'refs/signatures'.

		In addition to built in commit signing that allows -authors- to sign,
		Git Signatures allows parties other than the author to issue "approval"
		signatures to a ref, allowing for decentralized cryptographic proof of
		code review. This is also useful for automation use cases where CI
		systems to be able to add a signatures to a repo if a repo if all tests
		pass successfully.

		In practice Git Signatures allows for tamper evident design and brings
		strong code attestations to a deployment process.

		Commands
		--------

		* git signatures pull
			Pull all signatures for all refs from origin.

		* git signatures show
			Show signatures for a given ref.

		* git signatures push
			Push all signatures for all refs to origin.

		* git signatures add
			Add a signature to a given ref.

		* git signatures verify
			Verify signatures for a given ref.

		* git signatures version
			Report the version number.
		EOF
		;;

		"pull" ) cat <<-EOF
		TODO: add details on pull here
		EOF
		;;

		"show" ) cat <<-EOF
		TODO: add details on show here
		EOF
		;;

		"push" ) cat <<-EOF
		TODO: add details on push here
		EOF
		;;

		"add" ) cat <<-EOF
		TODO: add details on add here
		EOF
		;;

		"verify" ) cat <<-EOF
		TODO: add details on verify here
		EOF
		;;

		"version" ) cat <<-EOF
		TODO: add details on version here
		EOF
		;;

	esac
}

error() {
	code="${1:-}"
	case $code in

		"" ) cat <<-EOF
			Unknown error. Good luck!
		EOF
		;;

		"invalid_private_key" ) read -r -d '' template  <<-EOF
			Unable to create signature.

			This is not a valid private key according to GnuPG: "%s"

			Please set a public public key in your git configuration that has a
			valid local private key you control.

			> gpg --list-secret-keys
			> git config user.signingKey "YOURKEYID"
		EOF
		;;
	esac

	# shellcheck disable=SC2059
	printf "${template}\\n" "${@:2}"
}

path_check() {
	for item in "$@"; do
		if ! command -v "$item" >/dev/null; then
			printf "%s not found in \$PATH \\n" "$item";
			return 1;
		fi
	done
	return 0
}

cmd_version() {
	echo "$PROGRAM $VERSION"
}

cmd_add() {
	local opts key_id
	opts="$(getopt -o k: -l key: -n "$PROGRAM" -- "$@")";
	eval set -- "$opts"
	while true; do case $1 in
		-k|--key) key_id="$2"; shift 2 ;;
		--) shift; break ;;
	esac done
	[ "$#" -gt 2 ] && usage add && exit 1
	ref=${1:-HEAD}
	key=${key_id:-$(git config user.signingKey)}
	gpg --list-secret-keys "$key" &> /dev/null || {
		error "invalid_private_key" "$key"; exit 1;
	}
	signature=$( \
		git rev-parse "$ref" \
		| gpg --sign --local-user "$key" \
		| base64 -w0 \
	)
	printf "%s" "$signature" | git notes --ref refs/signatures append --file=-
}

cmd_pull() {
	# TODO
	[ "$#" -eq 0 ] || { usage pull; exit 1; }
	git fetch origin refs/signatures
	git notes merge -s cat_sort_uniq origin/refs/signatures
}

cmd_push() {
	# TODO
	[ "$#" -eq 0 ] || { usage push; exit 1; }
	git push origin refs/signatures
}

cmd_verify() {
	[ "$#" -eq 0 ] || { usage push; exit 1; }
	# TODO
}

cmd_show() {
	# TODO
	git notes --ref refs/signatures show | \
	  xargs -L1 -I {} sh -c "echo {} | base64 -d | gpg -d"
}

main "$@"
